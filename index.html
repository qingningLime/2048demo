<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>2048 Game</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100vh;
      background-color: #f2f2f2;
      margin: 0;
      flex-direction: column;
    }
    #score, #best-score, #move-count {
      font-size: 24px;
      margin-bottom: 10px;
    }
    .game-container {
      width: 400px;
      height: 400px;
      background-color: #bbada0;
      border-radius: 10px;
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      grid-template-rows: repeat(4, 1fr);
      gap: 10px;
      padding: 10px;
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
    }

    .tile {
      background-color: #ccc0b4;
      border-radius: 10px;
      display: flex;
      justify-content: center;
      align-items: center;
      font-size: 36px;
      font-weight: bold;
      color: #776e65;
      transition: transform 0.2s ease-in-out, background-color 0.2s ease-in-out;
    }
    .tile-2 { background-color: #eee4da; }
    .tile-4 { background-color: #ede0c8; }
    .tile-8 { background-color: #f2b179; }
    .tile-16 { background-color: #f59563; }
    .tile-32 { background-color: #f67c5f; }
    .tile-64 { background-color: #f65e3b; }
    .tile-128 { background-color: #edcf72; }
    .tile-256 { background-color: #edcc61; }
    .tile-512 { background-color: #edc850; }
    .tile-1024 { background-color: #edc53f; }
    .tile-2048 { background-color: #edc22e; }
    .tile-2, .tile-4 { color: #776e65; }
    .tile-8, .tile-16, .tile-32, .tile-64 { color: #f9f6f2; }
    .tile-128, .tile-256, .tile-512, .tile-1024, .tile-2048 { color: #f9f6f2; }
    .merge {
      animation: merge 0.2s ease-in-out;
    }
    @keyframes merge {
      0% { transform: scale(1); }
      50% { transform: scale(1.1); }
      100% { transform: scale(1); }
    }

    button {
      background-color: #8f7a66;
      color: #fff;
      border: none;
      padding: 10px 20px;
      font-size: 18px;
      border-radius: 5px;
      cursor: pointer;
      transition: background-color 0.3s ease;
    }

    button:hover {
      background-color: #9e8b76;
    }


    .popup {
    display: none;
    position: fixed;
    z-index: 1;
    left: 0;
    top: 0;
    width: 100%;
    height: 100%;
    overflow: auto;
    background-color: rgba(0,0,0,0.4);
    }

    .popup-content {
    background-color: #fefefe;
    margin: 15% auto;
    padding: 20px;
    border: 1px solid #888;
    width: 80%;
    border-radius: 10px;
    }

    .close-popup {
    color: #aaa;
    float: right;
    font-size: 28px;
    font-weight: bold;
    }

    .close-popup:hover,
    .close-popup:focus {
    color: black;
    text-decoration: none;
    cursor: pointer;
    }

  </style>
</head>
<body>

<div id="score">Score: 0</div>
<div id="best-score">Best Score: 0</div>
<div id="move-count">Move Count: 0</div>
<button id="reset-button">Reset Game</button>
<div class="game-container" id="game-board"></div>
<div id="popup" class="popup">
  <div class="popup-content">
    <span id="close-popup" class="close-popup">&times;</span>
    <p id="popup-message"></p>
  </div>
</div>

<script>
  const boardSize = 4;
  const board = [];
  const gameBoard = document.getElementById('game-board');
  let score = 0;
  let bestScore = localStorage.getItem('bestScore') || 0;
  let moveCount = 0;
  let stepCount = 0; // 添加一个变量来跟踪玩家的步数
  let obstacleRounds = 5; // 添加一个一个变量来跟踪障碍物剩余回合数
  let isPopupVisible = false;// 添加一个变量来跟踪弹出窗口是否可见



  document.getElementById('best-score').textContent = `Best Score: ${bestScore}`;

    function initializeBoard() {
    for (let i = 0; i < boardSize; i++) {
        board[i] = [];
        // obstacleRounds[i] = []; // 初始化障碍物剩余回合数数组
        for (let j = 0; j < boardSize; j++) {
        board[i][j] = 0;
        // obstacleRounds[i][j] = 0; // 初始化障碍物剩余回合数为0
        }
    }
    moveCount = 0;
    stepCount = 0;
    document.getElementById('move-count').textContent = 'Move Count: 0';
    addRandomTile();
    addRandomTile();
    renderBoard();
    }


  function addRandomTile() {
    const emptyCells = [];
    for (let i = 0; i < boardSize; i++) {
      for (let j = 0; j < boardSize; j++) {
        if (board[i][j] === 0) {
          emptyCells.push({ row: i, col: j });
        }
      }
    }
    if (emptyCells.length > 0) {
      const randomCell = emptyCells[Math.floor(Math.random() * emptyCells.length)];
      board[randomCell.row][randomCell.col] = Math.random() > 0.9 ? 4 : 2;
    }
  }

  function renderBoard() {
    gameBoard.innerHTML = '';
    for (let i = 0; i < boardSize; i++) {
      for (let j = 0; j < boardSize; j++) {
        const tile = document.createElement('div');
        tile.classList.add('tile');
        if (board[i][j] !== 0) {
          tile.classList.add(`tile-${board[i][j]}`);
          tile.textContent = board[i][j];
        }
        gameBoard.appendChild(tile);
      }
    }
  }

  function updateScore(amount) {
    score += amount;
    document.getElementById('score').textContent = `Score: ${score}`;
  }

  function updateBestScore() {
    if (score > bestScore) {
      bestScore = score;
      localStorage.setItem('bestScore', bestScore);
      document.getElementById('best-score').textContent = `Best Score: ${bestScore}`;
    }
  }

  function checkGameOver() {
    for (let i = 0; i < boardSize; i++) {
      for (let j = 0; j < boardSize; j++) {
        if (board[i][j] === 0) {
          return false;
        }
        if ((i > 0 && board[i][j] === board[i - 1][j]) || 
            (j > 0 && board[i][j] === board[i][j - 1])) {
          return false;
        }
      }
    }
    return true;
  }


  function moveTiles(direction) {
    let moved = false;
    switch (direction) {
      case 'up':
        for (let j = 0; j < boardSize; j++) {
          for (let i = 1; i < boardSize; i++) {
            if (board[i][j] !== 0) {
              let k = i;
              while (k > 0 && board[k - 1][j] === 0) {
                board[k - 1][j] = board[k][j];
                board[k][j] = 0;
                k--;
                moved = true;
              }
              if (k > 0 && board[k - 1][j] === board[k][j]) {
                board[k - 1][j] *= 2;
                board[k][j] = 0;
                updateScore(board[k - 1][j]);
                moved = true;
              }
            }
          }
        }
        break;
      case 'down':
        for (let j = 0; j < boardSize; j++) {
          for (let i = boardSize - 2; i >= 0; i--) {
            if (board[i][j] !== 0) {
              let k = i;
              while (k < boardSize - 1 && board[k + 1][j] === 0) {
                board[k + 1][j] = board[k][j];
                board[k][j] = 0;
                k++;
                moved = true;
              }
              if (k < boardSize - 1 && board[k + 1][j] === board[k][j]) {
                board[k + 1][j] *= 2;
                board[k][j] = 0;
                updateScore(board[k + 1][j]);
                moved = true;
              }
            }
          }
        }
        break;
      case 'left':
        for (let i = 0; i < boardSize; i++) {
          for (let j = 1; j < boardSize; j++) {
            if (board[i][j] !== 0) {
              let k = j;
              while (k > 0 && board[i][k - 1] === 0) {
                board[i][k - 1] = board[i][k];
                board[i][k] = 0;
                k--;
                moved = true;
              }
              if (k > 0 && board[i][k - 1] === board[i][k]) {
                board[i][k - 1] *= 2;
                board[i][k] = 0;
                updateScore(board[i][k - 1]);
                moved = true;
              }
            }
          }
        }
        break;
      case 'right':
        for (let i = 0; i < boardSize; i++) {
          for (let j = boardSize - 2; j >= 0; j--) {
            if (board[i][j] !== 0) {
              let k = j;
              while (k < boardSize - 1 && board[i][k + 1] === 0) {
                board[i][k + 1] = board[i][k];
                board[i][k] = 0;
                k++;
                moved = true;
              }
              if (k < boardSize - 1 && board[i][k + 1] === board[i][k]) {
                board[i][k + 1] *= 2;
                board[i][k] = 0;
                updateScore(board[i][k + 1]);
                moved = true;
              }
            }
          }
        }
        break;
    }
    if (moved) {
    moveCount++;
    stepCount++;
    document.getElementById('move-count').textContent = `Move Count: ${moveCount}`;
    updateObstacleRounds(); // 更新障碍物剩余回合数
    if (stepCount % 15 === 0) {
        triggerRandomEffect();
    }
    addRandomTile();
    if (checkGameOver()) {
        alert('Game Over');
        updateBestScore();
        score = 0;
        moveCount = 0;
        stepCount = 0;
        document.getElementById('score').textContent = 'Score: 0';
        document.getElementById('move-count').textContent = 'Move Count: 0';
        initializeBoard();
    }
    }


    renderBoard();
  }
  //获取键盘输入
  document.addEventListener('keydown', (event) => {
      if (!isPopupVisible) {
          switch (event.key) {
              case 'ArrowUp':
                  moveTiles('up');
                  break;
              case 'ArrowDown':
                  moveTiles('down');
                  break;
              case 'ArrowLeft':
                  moveTiles('left');
                  break;
              case 'ArrowRight':
                  moveTiles('right');
                  break;
          }
      }
    }
  );

  document.getElementById('reset-button').addEventListener('click', () => {
    score = 0;
    moveCount = 0;
    document.getElementById('score').textContent = 'Score: 0';
    document.getElementById('move-count').textContent = 'Move Count: 0';
    initializeBoard();
  });

  initializeBoard();
//随机事件生成
    function triggerRandomEffect() {
    const effect = Math.floor(Math.random() * 3); // 生成一个0到2之间的随机数
    switch (effect) {
        case 0:
        showPopup('特殊事件！', '障碍物出现了！');
        addObstacle();
        break;
        case 1:
        showPopup('特殊事件！', '只保留了最高值的方块！');
        keepHighestValue();
        break;
        case 2:
        showPopup('特殊事件！', '空位已填充！');
        fillEmptyCells();
        break;
    }
    }

    //弹窗
    function showPopup(title, message) {
    document.getElementById('popup-message').innerHTML = `<strong>${title}</strong><br>${message}`;
    document.getElementById('popup').style.display = 'block';
    isPopupVisible = true;
    document.getElementById('close-popup').addEventListener('click', () => {
        document.getElementById('popup').style.display = 'none';
        isPopupVisible = false;
    });
    }


    //第一个随机事件
    // 1. 障碍物出现• 效果描述：棋盘上随机出现一个无法合成的“X”数字方块。该方块会占据一个格子，且在5回合后自动消失。• 持续时间：5回合后自动消失。
    function addObstacle() {
    const emptyCells = [];
    for (let i = 0; i < boardSize; i++) {
        for (let j = 0; j < boardSize; j++) {
        if (board[i][j] === 0) {
            emptyCells.push({ row: i, col: j });
        }
        }
    }
    if (emptyCells.length > 0) {
        const randomCell = emptyCells[Math.floor(Math.random() * emptyCells.length)];
        board[randomCell.row][randomCell.col] = 'X';
        //定义一个函数存储障碍物剩余回合
        obstacleRounds = 5;
    }
    }

    function updateObstacleRounds() {
    for (let i = 0; i < boardSize; i++) {
        for (let j = 0; j < boardSize; j++) {
        if (board[i][j] === 'X') {
            obstacleRounds--;
            if (obstacleRounds === 0) {
            board[i][j] = 0; // 移除障碍物
            }
        }
        }
    }
    }

    //第二个随机事件
    //2. 保留最高值• 效果描述：棋盘上只保留数值最高的一个方块，其余所有方块均被清除。如果存在多个相同最高值的方块，随机保留其中一个。• 持续时间：仅在该回合生效。
    function keepHighestValue() {
    let highestValue = 0;
    for (let i = 0; i < boardSize; i++) {
        for (let j = 0; j < boardSize; j++) {
        if (board[i][j] > highestValue) {
            highestValue = board[i][j];
        }
        }
    }
    for (let i = 0; i < boardSize; i++) {
        for (let j = 0; j < boardSize; j++) {
        if (board[i][j] !== highestValue) {
            board[i][j] = 0;
        }
        }
    }
    }
    //第三个随机事件
    //3. 空位填充• 效果描述：棋盘上所有空余的位置都将被自动填充为2。如果棋盘上没有空位，则该效果不生效。• 持续时间：仅在该回合生效。
    function fillEmptyCells() {
    for (let i = 0; i < boardSize; i++) {
        for (let j = 0; j < boardSize; j++) {
        if (board[i][j] === 0) {
            board[i][j] = 2;
        }
        }
      }
    }
</script>

</body>
</html>
